From 1ae3e7494f0b7d69dd85cf881477d70f2f56582f Mon Sep 17 00:00:00 2001
From: chenyuanbo <chenyuanbo@eswincomputing.com>
Date: Thu, 25 Jul 2024 11:04:21 +0800
Subject: [PATCH] S500 bringup

1,added S500 device tree
2,added S500 clint and plic device usage files

Signed-off-by: chen yuanbo <chenyuanbo@eswincomputing.com>
---
 arch/riscv/Kconfig                            |   2 +-
 arch/riscv/Kconfig.socs                       |   9 +
 arch/riscv/boot/dts/Makefile                  |   1 +
 arch/riscv/boot/dts/eswin/Makefile            |   8 +
 arch/riscv/boot/dts/eswin/S500-haps.dts       |  97 ++++
 arch/riscv/boot/dts/eswin/S500-s2c.dts        |  88 ++++
 arch/riscv/boot/dts/eswin/S500-zebu.dts       |  72 +++
 arch/riscv/boot/dts/eswin/S500.dtsi           |  34 ++
 arch/riscv/boot/dts/eswin/eswin-a-series.dtsi | 216 +++++++++
 arch/riscv/configs/S500_defconfig             | 124 +++++
 drivers/clocksource/Kconfig                   |   8 +
 drivers/clocksource/Makefile                  |   2 +
 drivers/clocksource/timer-eswin-clint.c       | 293 ++++++++++++
 drivers/irqchip/Kconfig                       |  13 +
 drivers/irqchip/Makefile                      |   2 +
 drivers/irqchip/irq-eswin-plic.c              | 431 ++++++++++++++++++
 drivers/tty/serial/8250/8250_dw.c             |   4 +-
 17 files changed, 1401 insertions(+), 3 deletions(-)
 create mode 100644 arch/riscv/boot/dts/eswin/Makefile
 create mode 100644 arch/riscv/boot/dts/eswin/S500-haps.dts
 create mode 100644 arch/riscv/boot/dts/eswin/S500-s2c.dts
 create mode 100644 arch/riscv/boot/dts/eswin/S500-zebu.dts
 create mode 100644 arch/riscv/boot/dts/eswin/S500.dtsi
 create mode 100644 arch/riscv/boot/dts/eswin/eswin-a-series.dtsi
 create mode 100644 arch/riscv/configs/S500_defconfig
 create mode 100644 drivers/clocksource/timer-eswin-clint.c
 create mode 100644 drivers/irqchip/irq-eswin-plic.c

diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index d702359f8ab5..8b05e1fcf3e5 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -124,7 +124,7 @@ config RISCV
 	select PCI_DOMAINS_GENERIC if PCI
 	select PCI_MSI if PCI
 	select RISCV_INTC
-	select RISCV_TIMER if RISCV_SBI
+	#select RISCV_TIMER if RISCV_SBI
 	select SPARSE_IRQ
 	select SYSCTL_EXCEPTION_TRACE
 	select THREAD_INFO_IN_TASK
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 69774bb362d6..2faee10b924f 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -80,4 +80,13 @@ config SOC_CANAAN_K210_DTB_SOURCE
 
 endif # SOC_CANAAN
 
+config SOC_ESWIN
+    bool "ESWIN SoCs"
+	select DW_APB_TIMER_OF
+	select ESWIN_CLINT_TIMER
+	select ESWIN_PLIC
+	help
+	  This enables support for ESWIN SoC platform hardware.
+	  Build a device tree for the ESWIN S500 into the Linux image.
+
 endmenu # "SoC selection"
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index ff174996cdfd..a345dbc46ec0 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -3,5 +3,6 @@ subdir-y += sifive
 subdir-y += starfive
 subdir-$(CONFIG_SOC_CANAAN_K210_DTB_BUILTIN) += canaan
 subdir-y += microchip
+subdir-y += eswin
 
 obj-$(CONFIG_BUILTIN_DTB) := $(addsuffix /, $(subdir-y))
diff --git a/arch/riscv/boot/dts/eswin/Makefile b/arch/riscv/boot/dts/eswin/Makefile
new file mode 100644
index 000000000000..0600f0dd5f4d
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+#
+dtb-$(CONFIG_SOC_ESWIN) += S500-haps.dtb
+dtb-$(CONFIG_SOC_ESWIN) += S500-zebu.dtb
+dtb-$(CONFIG_SOC_ESWIN) += S500-s2c.dtb
+
diff --git a/arch/riscv/boot/dts/eswin/S500-haps.dts b/arch/riscv/boot/dts/eswin/S500-haps.dts
new file mode 100644
index 000000000000..126be60cb6ba
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/S500-haps.dts
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+*
+* Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+*
+*/
+
+/dts-v1/;
+
+#include "S500.dtsi"
+
+/ {
+	model = "eswin S500";
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0x00000000 0x80000000>;
+	};
+
+	memory@280000000 {
+		device_type = "memory";
+		reg = <0x00000002 0x80000000 0x00000001 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		dap@c0000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x00000000 0xc0000000 0x00000000 0x40000000>;
+			status = "okay";
+		};
+	};
+};
+
+&cpu {
+	timebase-frequency = <20000000>;
+};
+
+&cpu0 {
+	status = "okay";
+};
+
+&cpu1 {
+	status = "okay";
+};
+
+&cpu2 {
+	status = "okay";
+};
+
+&cpu3 {
+	status = "okay";
+};
+
+&reset {
+	status = "okay";
+};
+
+&clint0 {
+	status = "okay";
+};
+
+&intc {
+	status = "okay";
+};
+
+&dummy_apb {
+	clock-frequency = <20000000>;
+	status = "okay";
+};
+
+&dummy_eth {
+	status = "disabled";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&eth0 {
+	status = "disabled";
+};
+
+&wdt0 {
+	status = "okay";
+};
+
+&dmac0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
diff --git a/arch/riscv/boot/dts/eswin/S500-s2c.dts b/arch/riscv/boot/dts/eswin/S500-s2c.dts
new file mode 100644
index 000000000000..4205fd588337
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/S500-s2c.dts
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+*
+* Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+*
+*/
+
+/dts-v1/;
+
+#include "S500.dtsi"
+
+/ {
+	model = "eswin S500";
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0x00000000 0x80000000>;
+	};
+
+	memory@280000000 {
+		device_type = "memory";
+		reg = <0x00000002 0x80000000 0x00000001 0x80000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		dap@c0000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x00000000 0xc0000000 0x00000000 0x40000000>;
+			status = "okay";
+		};
+	};
+};
+
+&cpu {
+	timebase-frequency = <20000000>;
+};
+
+&cpu0 {
+	status = "okay";
+};
+
+&cpu1 {
+	status = "okay";
+};
+
+&cpu2 {
+	status = "okay";
+};
+
+&cpu3 {
+	status = "okay";
+};
+
+&reset {
+	status = "okay";
+};
+
+&clint0 {
+	status = "okay";
+};
+
+&intc {
+	status = "okay";
+};
+
+&dummy_apb {
+	clock-frequency = <20000000>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&wdt0 {
+	status = "okay";
+};
+
+&dmac0 {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
diff --git a/arch/riscv/boot/dts/eswin/S500-zebu.dts b/arch/riscv/boot/dts/eswin/S500-zebu.dts
new file mode 100644
index 000000000000..9760456c3860
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/S500-zebu.dts
@@ -0,0 +1,72 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+*
+* Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+*
+*/
+
+/dts-v1/;
+
+#include "S500.dtsi"
+
+/ {
+	model = "eswin S500";
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0x00000000 0x80000000>;
+	};
+};
+
+&cpu {
+	timebase-frequency = <10000000>;
+};
+
+&cpu0 {
+	status = "okay";
+};
+
+&cpu1 {
+	status = "okay";
+};
+
+&cpu2 {
+	status = "okay";
+};
+
+&cpu3 {
+	status = "okay";
+};
+
+&reset {
+	status = "disabled";
+};
+
+&clint0 {
+	status = "okay";
+};
+
+&intc {
+	status = "okay";
+};
+
+&dummy_apb {
+	clock-frequency = <10000000>;
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&wdt0 {
+	status = "disable";
+};
+
+&dmac0 {
+	status = "disable";
+};
+
+&timer0 {
+	status = "disable";
+};
diff --git a/arch/riscv/boot/dts/eswin/S500.dtsi b/arch/riscv/boot/dts/eswin/S500.dtsi
new file mode 100644
index 000000000000..f104374e734e
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/S500.dtsi
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+*
+* Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+*
+*/
+
+/dts-v1/;
+
+#include "eswin-a-series.dtsi"
+
+/ {
+	compatible = "eswin,S500";
+};
+
+&cpu0 {
+	riscv,isa = "rv64imafdcb";
+	riscv,model = "eswin,S500";
+};
+
+&cpu1 {
+	riscv,isa = "rv64imafdcb";
+	riscv,model = "eswin,S500";
+};
+
+&cpu2 {
+	riscv,isa = "rv64imafdcb";
+	riscv,model = "eswin,S500";
+};
+
+&cpu3 {
+	riscv,isa = "rv64imafdcb";
+	riscv,model = "eswin,S500";
+};
diff --git a/arch/riscv/boot/dts/eswin/eswin-a-series.dtsi b/arch/riscv/boot/dts/eswin/eswin-a-series.dtsi
new file mode 100644
index 000000000000..e0a72756e482
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/eswin-a-series.dtsi
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+*
+* Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+*
+*/
+
+/dts-v1/;
+/ {
+	compatible = "eswin,a-series";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpu: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <10000000>;
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			reg = <0>;
+			status = "disabled";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcbvx";
+			riscv,model = "eswin,a-series";
+			mmu-type = "riscv,sv39";
+			cpu0_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			reg = <1>;
+			status = "disabled";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcbvx";
+			riscv,model = "eswin,a-series";
+			mmu-type = "riscv,sv39";
+			cpu1_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			reg = <2>;
+			status = "disabled";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcbvx";
+			riscv,model = "eswin,a-series";
+			mmu-type = "riscv,sv39";
+			cpu2_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			reg = <3>;
+			status = "disabled";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdcbvx";
+			riscv,model = "eswin,a-series";
+			mmu-type = "riscv,sv39";
+			cpu3_intc: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		reset: reset-sample {
+			compatible = "eswin,reset-sample";
+			#reset-cells = <0>;
+			plic-delegate = <0x0 0x03200ffc>;
+			using-csr-reset;
+			csr-copy = <
+				0x7c0 0x7c1 0x7c2 0x7c3 0x7c5 0x7cc
+				0x3b0 0x3b1 0x3b2 0x3b3
+				0x3b4 0x3b5 0x3b6 0x3b7
+				0x3a0
+				>;
+			status = "disabled";
+		};
+
+		clint0: clint@2000000 {
+			compatible = "eswin,clint0";
+			reg = <0x0 0x02000000 0x0 0x00010000>;
+			clint,has-no-64bit-mmio;
+			status = "disabled";
+			interrupts-extended = <
+                		&cpu0_intc  1 &cpu0_intc  5
+                		&cpu1_intc  1 &cpu1_intc  5
+                		&cpu2_intc  1 &cpu2_intc  5
+                		&cpu3_intc  1 &cpu3_intc  5
+				>;
+		};
+
+		intc: interrupt-controller@3000000 {
+			#interrupt-cells = <1>;
+			compatible = "eswin,plic0";
+			interrupt-controller;
+			reg = <0x0 0x03000000 0x0 0x01000000>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev = <80>;
+			status = "disabled";
+			interrupts-extended = <
+				&cpu0_intc  0xffffffff &cpu0_intc  0x9
+                		&cpu1_intc  0xffffffff &cpu1_intc  0x9
+                		&cpu2_intc  0xffffffff &cpu2_intc  0x9
+                		&cpu3_intc  0xffffffff &cpu3_intc  0x9
+				>;
+		};
+
+		dummy_apb: apb-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <10000000>;
+			clock-output-names = "dummy_apb";
+			#clock-cells = <0>;
+			status = "disabled";
+		};
+
+		dummy_eth: eth-clock {
+			compatible = "fixed-clock";
+			clock-frequency = <125000000>;
+			clock-output-names = "dummy_eth";
+			#clock-cells = <0>;
+			status = "disabled";
+		};
+
+		uart0: serial@20100000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x00000000 0x20100000 0x00000000 0x00000400>;
+			interrupt-parent = <&intc>;
+			interrupts = <16>;
+			clocks = <&dummy_apb>;
+			clock-names = "baudclk";
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		eth0: ethernet@20800000 {
+			compatible = "cdns,gem";
+			interrupt-parent = <&intc>;
+			interrupts = <17>;
+			reg = <0x00000000 0x20800000 0x00000000 0x00100000>;
+			local-mac-address = [10 23 45 67 89 ab];
+			clocks = <&dummy_apb>, <&dummy_apb>, <&dummy_eth>, <&dummy_eth>;
+			clock-names = "pclk", "hclk", "tx_clk", "rx_clk";
+			phy-mode = "gmii";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			phy0: ethernet-phy@0 {
+				reg = <0x0>;
+			};
+		};
+
+		dmac0: dma-controller@20a00000 {
+			compatible = "snps,dma-spear1340";
+			reg = <0x00000000 0x20a00000 0x00000000 0x00001000>;
+			interrupt-parent = <&intc>;
+			interrupts = <18>;
+			clocks = <&dummy_apb>;
+			clock-names = "hclk";
+			dma-channels = <2>;
+			dma-requests = <8>;
+			dma-masters = <1>;
+			#dma-cells = <3>;
+			chan_allocation_order = <0>;
+			chan_priority = <0>;
+			block_size = <511>;
+			data-width = <4>;
+			multi-block = <0 0>;
+			snps,max-burst-len = <256 256>;
+			//snps,dma-protection-control = <7>;
+			status = "disabled";
+		};
+
+		wdt0: watchdog@20120000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x00000000 0x20120000 0x00000000 0x00001000>;
+			interrupt-parent = <&intc>;
+			interrupts = <27>;
+			clocks = <&dummy_apb>;
+			status = "disabled";
+		};
+
+		timer0: timer@20130000 {
+			compatible = "snps,dw-apb-timer";
+			reg = <0x00000000 0x20130000 0x00000000 0x00000100>;
+			interrupt-parent = <&intc>;
+			interrupts = <19>, <20>, <21>, <22>, <23>, <24>, <25>, <26>;
+			clocks = <&dummy_apb>, <&dummy_apb>;
+			clock-names = "timer", "pclk";
+			status = "disabled";
+		};
+	};
+
+	chosen {
+		stdout-path = "uart0:38400";
+	};
+};
+
diff --git a/arch/riscv/configs/S500_defconfig b/arch/riscv/configs/S500_defconfig
new file mode 100644
index 000000000000..b24adaa1e8db
--- /dev/null
+++ b/arch/riscv/configs/S500_defconfig
@@ -0,0 +1,124 @@
+CONFIG_DEFAULT_HOSTNAME="ESWIN-S500"
+CONFIG_SYSVIPC=y
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+CONFIG_BPF_SYSCALL=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BOOT_CONFIG=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_ESWIN=y
+CONFIG_SMP=y
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_RISCV_ISA_SVPBMT is not set
+CONFIG_HZ_25=y
+CONFIG_RISCV_SBI_V01=y
+# CONFIG_EFI is not set
+CONFIG_PM=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+CONFIG_ACORN_PARTITION_CUMANA=y
+CONFIG_ACORN_PARTITION_EESOX=y
+CONFIG_ACORN_PARTITION_ICS=y
+CONFIG_ACORN_PARTITION_ADFS=y
+CONFIG_ACORN_PARTITION_POWERTEC=y
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_AIX_PARTITION=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+CONFIG_LDM_DEBUG=y
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_CMDLINE_PARTITION=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_VT is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_HVC_RISCV_SBI=y
+CONFIG_TTY_PRINTK=y
+CONFIG_PPS=y
+CONFIG_GPIOLIB=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_SYSCON=y
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_SYNC_FILE=y
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VHOST_MENU is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_BCM_KONA_USB2_PHY=y
+CONFIG_PHY_CADENCE_TORRENT=y
+CONFIG_PHY_CADENCE_DPHY=y
+CONFIG_PHY_CADENCE_SALVO=y
+CONFIG_PHY_PXA_28NM_HSIC=y
+CONFIG_PHY_PXA_28NM_USB2=y
+CONFIG_PHY_OCELOT_SERDES=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_UTF8=y
+CONFIG_KEYS=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_IRQ_POLL=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_DEBUG_MISC is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_MAGIC_SYSRQ_SERIAL is not set
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 4469e7f555e9..578a1c87fee7 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -639,6 +639,14 @@ config CLINT_TIMER
 	  This option enables the CLINT timer for RISC-V systems.  The CLINT
 	  driver is usually used for NoMMU RISC-V systems.
 
+config ESWIN_CLINT_TIMER
+	bool "CLINT Timer for the ESWIN RISC-V platform" if COMPILE_TEST
+	depends on GENERIC_SCHED_CLOCK && RISCV
+	select TIMER_PROBE
+	select TIMER_OF
+	help
+	  This option enables the ESWIN S500 CLINT timer for RISC-V systems.
+
 config CSKY_MP_TIMER
 	bool "SMP Timer for the C-SKY platform" if COMPILE_TEST
 	depends on CSKY
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index 64ab547de97b..f59ec3bdd2fd 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -81,6 +81,8 @@ obj-$(CONFIG_CLKSRC_ST_LPC)		+= clksrc_st_lpc.o
 obj-$(CONFIG_X86_NUMACHIP)		+= numachip.o
 obj-$(CONFIG_RISCV_TIMER)		+= timer-riscv.o
 obj-$(CONFIG_CLINT_TIMER)		+= timer-clint.o
+
+obj-$(CONFIG_ESWIN_CLINT_TIMER)		+= timer-eswin-clint.o
 obj-$(CONFIG_CSKY_MP_TIMER)		+= timer-mp-csky.o
 obj-$(CONFIG_GX6605S_TIMER)		+= timer-gx6605s.o
 obj-$(CONFIG_HYPERV_TIMER)		+= hyperv_timer.o
diff --git a/drivers/clocksource/timer-eswin-clint.c b/drivers/clocksource/timer-eswin-clint.c
new file mode 100644
index 000000000000..84a65074dec9
--- /dev/null
+++ b/drivers/clocksource/timer-eswin-clint.c
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 Western Digital Corporation or its affiliates.
+ * Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+ *
+ * Most of the M-mode (i.e. NoMMU) RISC-V systems usually have a
+ * CLINT MMIO timer device.
+ *
+ * Author: chen yuanbo <chenyuanbo@eswincomputing.com>
+ */
+
+#define pr_fmt(fmt) "eswin-clint: " fmt
+#include <linux/bitops.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/cpu.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/sched_clock.h>
+#include <linux/io-64-nonatomic-lo-hi.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include <linux/smp.h>
+#include <linux/timex.h>
+#include <asm/sbi.h>
+
+#ifndef CONFIG_RISCV_M_MODE
+#include <asm/clint.h>
+#endif
+
+#ifndef CONFIG_RISCV_M_MODE
+#define CLINT_IPI_OFF		0xc000
+#define CLINT_TIMER_CMP_OFF	0xd000
+#define CLINT_IPI_HART_OFF  (0x100/4)
+#define CLINT_IPI_DID_OFF   1
+#define CLINT_TIMER_HART_OFF	(0x100/8)
+#define CLINT_TIMER_DID_OFF 1
+#else
+#define CLINT_IPI_OFF		0
+#define CLINT_TIMER_CMP_OFF	0x4000
+#define CLINT_IPI_HART_OFF  1
+#define CLINT_IPI_DID_OFF   0
+#define CLINT_TIMER_HART_OFF	1
+#define CLINT_TIMER_DID_OFF 0
+#endif
+#define CLINT_TIMER_VAL_OFF	0xbff8
+
+/* CLINT manages IPI and Timer for RISC-V M-mode  */
+static u32 __iomem *clint_ipi_base;
+static u64 __iomem *clint_timer_cmp;
+static u64 __iomem *clint_timer_val;
+static unsigned long clint_timer_freq;
+static unsigned int clint_timer_irq;
+
+/* CLINT S-mode domain id */
+static unsigned int did;
+
+#ifdef CONFIG_RISCV_M_MODE
+u64 __iomem *clint_time_val;
+EXPORT_SYMBOL(clint_time_val);
+#endif
+
+static void clint_send_ipi(const struct cpumask *target)
+{
+	unsigned int cpu;
+
+	for_each_cpu(cpu, target)
+		writel(1, clint_ipi_base + CLINT_IPI_HART_OFF * cpuid_to_hartid_map(cpu)
+			+ CLINT_IPI_DID_OFF * did);
+}
+
+static void clint_clear_ipi(void)
+{
+	writel(0, clint_ipi_base + CLINT_IPI_HART_OFF * cpuid_to_hartid_map(smp_processor_id())
+		+ CLINT_IPI_DID_OFF * did);
+}
+
+static struct riscv_ipi_ops clint_ipi_ops = {
+	.ipi_inject = clint_send_ipi,
+	.ipi_clear = clint_clear_ipi,
+};
+
+#ifdef CONFIG_64BIT
+#ifdef CONFIG_RISCV_M_MODE
+#define clint_get_cycles()	readq_relaxed(clint_timer_val)
+#else
+static inline u64 clint_get_cycles(void)
+{
+	u64 val;
+	asm volatile("rdtime %0" : "=r"(val));
+	return val;
+}
+#endif
+#else
+#define clint_get_cycles()	readl_relaxed(clint_timer_val)
+#define clint_get_cycles_hi()	readl_relaxed(((u32 *)clint_timer_val) + 1)
+#endif
+
+#ifdef CONFIG_64BIT
+static u64 notrace clint_get_cycles64(void)
+{
+	return clint_get_cycles();
+}
+#else /* CONFIG_64BIT */
+static u64 notrace clint_get_cycles64(void)
+{
+	u32 hi, lo;
+
+	do {
+		hi = clint_get_cycles_hi();
+		lo = clint_get_cycles();
+	} while (hi != clint_get_cycles_hi());
+
+	return ((u64)hi << 32) | lo;
+}
+#endif /* CONFIG_64BIT */
+
+static u64 clint_rdtime(struct clocksource *cs)
+{
+	return clint_get_cycles64();
+}
+
+static struct clocksource clint_clocksource = {
+	.name		= "clint_clocksource",
+	.rating		= 300,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+	.read		= clint_rdtime,
+};
+
+static int clint_clock_next_event(unsigned long delta,
+				   struct clock_event_device *ce)
+{
+	void __iomem *r = clint_timer_cmp +
+			CLINT_TIMER_HART_OFF * cpuid_to_hartid_map(smp_processor_id()) +
+			CLINT_TIMER_DID_OFF * did;
+
+	csr_set(CSR_IE, IE_TIE);
+	// eswin-clint only support 32bit mmio
+	writel_relaxed((u32)((clint_get_cycles64() + delta) & (u32)-1), r);
+	writel_relaxed((u32)((clint_get_cycles64() + delta) >> 32), r + 4);
+
+	return 0;
+}
+
+static DEFINE_PER_CPU(struct clock_event_device, clint_clock_event) = {
+	.name		= "clint_clockevent",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.rating		= 100,
+	.set_next_event	= clint_clock_next_event,
+};
+
+static int clint_timer_starting_cpu(unsigned int cpu)
+{
+	struct clock_event_device *ce = per_cpu_ptr(&clint_clock_event, cpu);
+
+	ce->cpumask = cpumask_of(cpu);
+	clockevents_config_and_register(ce, clint_timer_freq, 100, 0x7fffffff);
+
+	enable_percpu_irq(clint_timer_irq,
+			  irq_get_trigger_type(clint_timer_irq));
+	return 0;
+}
+
+static int clint_timer_dying_cpu(unsigned int cpu)
+{
+	disable_percpu_irq(clint_timer_irq);
+	return 0;
+}
+
+static irqreturn_t clint_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evdev = this_cpu_ptr(&clint_clock_event);
+
+	csr_clear(CSR_IE, IE_TIE);
+	evdev->event_handler(evdev);
+
+	return IRQ_HANDLED;
+}
+
+static int __init clint_timer_init_dt(struct device_node *np)
+{
+	int rc;
+	u32 i, nr_irqs;
+	void __iomem *base;
+	struct of_phandle_args oirq;
+
+#ifndef CONFIG_RISCV_M_MODE
+	struct sbiret sbi_ret;
+	sbi_ret = sbi_ecall(0x534D4541, 0x200, 0, 0, 0, 0, 0, 0);
+	if (!sbi_ret.error)
+		did = sbi_ret.value;
+	else {
+		pr_err("query domain_id from SBI failed, assume domain_id = 0\n");
+		did = 0;
+	}
+#endif
+
+	/*
+	 * Ensure that CLINT device interrupts are either RV_IRQ_TIMER or
+	 * RV_IRQ_SOFT. If it's anything else then we ignore the device.
+	 */
+	nr_irqs = of_irq_count(np);
+	for (i = 0; i < nr_irqs; i++) {
+		if (of_irq_parse_one(np, i, &oirq)) {
+			pr_err("%pOFP: failed to parse irq %d.\n", np, i);
+			continue;
+		}
+
+		if ((oirq.args_count != 1) ||
+			(oirq.args[0] != RV_IRQ_TIMER &&
+			 oirq.args[0] != RV_IRQ_SOFT)) {
+			pr_err("%pOFP: invalid irq %d (hwirq %d)\n",
+				   np, i, oirq.args[0]);
+			return -ENODEV;
+		}
+
+		/* Find parent irq domain and map timer irq */
+		if (!clint_timer_irq &&
+			oirq.args[0] == RV_IRQ_TIMER &&
+			irq_find_host(oirq.np))
+			clint_timer_irq = irq_of_parse_and_map(np, i);
+	}
+
+	/* If CLINT timer irq not found then fail */
+	if (!clint_timer_irq) {
+		pr_err("%pOFP: timer irq not found\n", np);
+		return -ENODEV;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_err("%pOFP: could not map registers\n", np);
+		return -ENODEV;
+	}
+
+	clint_ipi_base = base + CLINT_IPI_OFF;
+	clint_timer_cmp = base + CLINT_TIMER_CMP_OFF;
+	clint_timer_val = base + CLINT_TIMER_VAL_OFF;
+	clint_timer_freq = riscv_timebase;
+
+#ifdef CONFIG_RISCV_M_MODE
+	/*
+	 * Yes, that's an odd naming scheme.  time_val is public, but hopefully
+	 * will die in favor of something cleaner.
+	 */
+	clint_time_val = clint_timer_val;
+#endif
+
+#ifndef CONFIG_RISCV_M_MODE
+	pr_info("%pOFP: timer running at %ld Hz, domain id: %d.\n", np, clint_timer_freq, did);
+#else
+	pr_info("%pOFP: timer running at %ld Hz\n", np, clint_timer_freq);
+#endif
+
+	rc = clocksource_register_hz(&clint_clocksource, clint_timer_freq);
+	if (rc) {
+		pr_err("%pOFP: clocksource register failed [%d]\n", np, rc);
+		goto fail_iounmap;
+	}
+
+	sched_clock_register(clint_get_cycles64, 64, clint_timer_freq);
+
+	rc = request_percpu_irq(clint_timer_irq, clint_timer_interrupt,
+				 "clint-timer", &clint_clock_event);
+	if (rc) {
+		pr_err("registering percpu irq failed [%d]\n", rc);
+		goto fail_iounmap;
+	}
+
+	rc = cpuhp_setup_state(CPUHP_AP_CLINT_TIMER_STARTING,
+				"clockevents/clint/timer:starting",
+				clint_timer_starting_cpu,
+				clint_timer_dying_cpu);
+	if (rc) {
+		pr_err("%pOFP: cpuhp setup state failed [%d]\n", np, rc);
+		goto fail_free_irq;
+	}
+
+	riscv_set_ipi_ops(&clint_ipi_ops);
+	clint_clear_ipi();
+
+	return 0;
+
+fail_free_irq:
+	free_irq(clint_timer_irq, &clint_clock_event);
+fail_iounmap:
+	iounmap(base);
+	return rc;
+}
+
+TIMER_OF_DECLARE(clint_timer, "eswin,clint0", clint_timer_init_dt);
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index a29a426e4eed..653e3026bc2d 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -565,6 +565,19 @@ config SIFIVE_PLIC
 
 	   If you don't know what to do here, say Y.
 
+config ESWIN_PLIC
+	bool "ESWIN Platform-Level Interrupt Controller"
+	depends on RISCV
+	select IRQ_DOMAIN_HIERARCHY
+	help
+	   This enables support for the PLIC chip found in ESWIN (and
+	   potentially other) RISC-V systems.  The PLIC controls devices
+	   interrupts and connects them to each core's local interrupt
+	   controller.  Aside from timer and software interrupts, all other
+	   interrupt sources are subordinate to the PLIC.
+
+	   If you don't know what to do here, say Y.
+
 config EXYNOS_IRQ_COMBINER
 	bool "Samsung Exynos IRQ combiner support" if COMPILE_TEST
 	depends on (ARCH_EXYNOS && ARM) || COMPILE_TEST
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 87b49a10962c..605c7af2e90d 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -97,6 +97,8 @@ obj-$(CONFIG_CSKY_MPINTC)		+= irq-csky-mpintc.o
 obj-$(CONFIG_CSKY_APB_INTC)		+= irq-csky-apb-intc.o
 obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o
 obj-$(CONFIG_SIFIVE_PLIC)		+= irq-sifive-plic.o
+
+obj-$(CONFIG_ESWIN_PLIC)		+= irq-eswin-plic.o
 obj-$(CONFIG_IMX_IRQSTEER)		+= irq-imx-irqsteer.o
 obj-$(CONFIG_IMX_INTMUX)		+= irq-imx-intmux.o
 obj-$(CONFIG_IMX_MU_MSI)		+= irq-imx-mu-msi.o
diff --git a/drivers/irqchip/irq-eswin-plic.c b/drivers/irqchip/irq-eswin-plic.c
new file mode 100644
index 000000000000..cc53d2d54df1
--- /dev/null
+++ b/drivers/irqchip/irq-eswin-plic.c
@@ -0,0 +1,431 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2017 SiFive
+ * Copyright (C) 2018 Christoph Hellwig
+ * Copyright 2024 Beijing ESWIN Computing Technology Co., Ltd.
+ * Author: chen yuanbo <chenyuanbo@eswincomputing.com>
+ */
+#define pr_fmt(fmt) "eswin-plic: " fmt
+#include <linux/cpu.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <asm/smp.h>
+#include <asm/sbi.h>
+
+/*
+ * This driver implements a version of the RISC-V PLIC with the actual layout
+ * specified in chapter 8 of the SiFive U5 Coreplex Series Manual:
+ *
+ *     https://static.dev.sifive.com/U54-MC-RVCoreIP.pdf
+ *
+ * The largest number supported by devices marked as 'sifive,plic-1.0.0', is
+ * 1024, of which device 0 is defined as non-existent by the RISC-V Privileged
+ * Spec.
+ */
+
+#define MAX_DEVICES			1024
+#define MAX_CONTEXTS			15872
+
+/*
+ * Each interrupt source has a priority register associated with it.
+ * We always hardwire it to one in Linux.
+ */
+#define PRIORITY_BASE			0
+#define     PRIORITY_PER_ID		4
+
+/*
+ * Each hart context has a vector of interrupt enable bits associated with it.
+ * There's one bit for each interrupt source.
+ */
+#define CONTEXT_ENABLE_BASE		0x2000
+#define     CONTEXT_ENABLE_SIZE		0x80
+
+/*
+ * Each hart context has a set of control registers associated with it.  Right
+ * now there's only two: a source priority threshold over which the hart will
+ * take an interrupt, and a register to claim interrupts.
+ */
+#define CONTEXT_BASE			0x200000
+#define     CONTEXT_SIZE		0x1000
+#define     CONTEXT_THRESHOLD		0x00
+#define     CONTEXT_CLAIM		0x04
+
+#define	PLIC_DISABLE_THRESHOLD		0x7
+#define	PLIC_ENABLE_THRESHOLD		0
+
+#define ESS_CONTEXT_MAP(i) ((i%2) ? (i/2)*32+did+1 : (i/2)*32)
+
+struct plic_priv {
+	struct cpumask lmask;
+	struct irq_domain *irqdomain;
+	void __iomem *regs;
+};
+
+struct plic_handler {
+	bool			present;
+	void __iomem		*hart_base;
+	/*
+	 * Protect mask operations on the registers given that we can't
+	 * assume atomic memory operations work on them.
+	 */
+	raw_spinlock_t		enable_lock;
+	void __iomem		*enable_base;
+	struct plic_priv	*priv;
+};
+static int plic_parent_irq __ro_after_init;
+static bool plic_cpuhp_setup_done __ro_after_init;
+static DEFINE_PER_CPU(struct plic_handler, plic_handlers);
+
+static void __plic_toggle(void __iomem *enable_base, int hwirq, int enable)
+{
+	u32 __iomem *reg = enable_base + (hwirq / 32) * sizeof(u32);
+	u32 hwirq_mask = 1 << (hwirq % 32);
+
+	if (enable)
+		writel(readl(reg) | hwirq_mask, reg);
+	else
+		writel(readl(reg) & ~hwirq_mask, reg);
+}
+
+static void plic_toggle(struct plic_handler *handler, int hwirq, int enable)
+{
+	raw_spin_lock(&handler->enable_lock);
+	__plic_toggle(handler->enable_base, hwirq, enable);
+	raw_spin_unlock(&handler->enable_lock);
+}
+
+static inline void plic_irq_toggle(const struct cpumask *mask,
+				   struct irq_data *d, int enable)
+{
+	int cpu;
+	struct plic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	writel(enable, priv->regs + PRIORITY_BASE + d->hwirq * PRIORITY_PER_ID);
+	for_each_cpu(cpu, mask) {
+		struct plic_handler *handler = per_cpu_ptr(&plic_handlers, cpu);
+
+		if (handler->present &&
+		    cpumask_test_cpu(cpu, &handler->priv->lmask))
+			plic_toggle(handler, d->hwirq, enable);
+	}
+}
+
+static void plic_irq_unmask(struct irq_data *d)
+{
+	struct cpumask amask;
+	unsigned int cpu;
+	struct plic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	cpumask_and(&amask, &priv->lmask, cpu_online_mask);
+	cpu = cpumask_any_and(irq_data_get_affinity_mask(d),
+					   &amask);
+	if (WARN_ON_ONCE(cpu >= nr_cpu_ids))
+		return;
+	plic_irq_toggle(cpumask_of(cpu), d, 1);
+}
+
+static void plic_irq_mask(struct irq_data *d)
+{
+	struct plic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	plic_irq_toggle(&priv->lmask, d, 0);
+}
+
+#ifdef CONFIG_SMP
+static int plic_set_affinity(struct irq_data *d,
+			     const struct cpumask *mask_val, bool force)
+{
+	unsigned int cpu;
+	struct cpumask amask;
+	struct plic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	cpumask_and(&amask, &priv->lmask, mask_val);
+
+	if (force)
+		cpu = cpumask_first(&amask);
+	else
+		cpu = cpumask_any_and(&amask, cpu_online_mask);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	plic_irq_toggle(&priv->lmask, d, 0);
+	plic_irq_toggle(cpumask_of(cpu), d, !irqd_irq_masked(d));
+
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+#endif
+
+static void plic_irq_eoi(struct irq_data *d)
+{
+	struct plic_handler *handler = this_cpu_ptr(&plic_handlers);
+
+	if (irqd_irq_masked(d)) {
+		plic_irq_unmask(d);
+		writel(d->hwirq, handler->hart_base + CONTEXT_CLAIM);
+		plic_irq_mask(d);
+	} else {
+		writel(d->hwirq, handler->hart_base + CONTEXT_CLAIM);
+	}
+}
+
+static struct irq_chip plic_chip = {
+	.name		= "SiFive PLIC",
+	.irq_mask	= plic_irq_mask,
+	.irq_unmask	= plic_irq_unmask,
+	.irq_eoi	= plic_irq_eoi,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = plic_set_affinity,
+#endif
+};
+
+static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq,
+			      irq_hw_number_t hwirq)
+{
+	struct plic_priv *priv = d->host_data;
+
+	irq_domain_set_info(d, irq, hwirq, &plic_chip, d->host_data,
+			    handle_fasteoi_irq, NULL, NULL);
+	irq_set_noprobe(irq);
+	irq_set_affinity(irq, &priv->lmask);
+	return 0;
+}
+
+static int plic_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
+				 unsigned int nr_irqs, void *arg)
+{
+	int i, ret;
+	irq_hw_number_t hwirq;
+	unsigned int type;
+	struct irq_fwspec *fwspec = arg;
+
+	ret = irq_domain_translate_onecell(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < nr_irqs; i++) {
+		ret = plic_irqdomain_map(domain, virq + i, hwirq + i);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops plic_irqdomain_ops = {
+	.translate	= irq_domain_translate_onecell,
+	.alloc		= plic_irq_domain_alloc,
+	.free		= irq_domain_free_irqs_top,
+};
+
+/*
+ * Handling an interrupt is a two-step process: first you claim the interrupt
+ * by reading the claim register, then you complete the interrupt by writing
+ * that source ID back to the same claim register.  This automatically enables
+ * and disables the interrupt, so there's nothing else to do.
+ */
+static void plic_handle_irq(struct irq_desc *desc)
+{
+	struct plic_handler *handler = this_cpu_ptr(&plic_handlers);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	void __iomem *claim = handler->hart_base + CONTEXT_CLAIM;
+	irq_hw_number_t hwirq;
+
+	WARN_ON_ONCE(!handler->present);
+
+	chained_irq_enter(chip, desc);
+
+	while ((hwirq = readl(claim))) {
+		int err = generic_handle_domain_irq(handler->priv->irqdomain,
+						    hwirq);
+		if (unlikely(err))
+			pr_warn_ratelimited("can't find mapping for hwirq %lu\n",
+					hwirq);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void plic_set_threshold(struct plic_handler *handler, u32 threshold)
+{
+	/* priority must be > threshold to trigger an interrupt */
+	writel(threshold, handler->hart_base + CONTEXT_THRESHOLD);
+}
+
+static int plic_dying_cpu(unsigned int cpu)
+{
+	if (plic_parent_irq)
+		disable_percpu_irq(plic_parent_irq);
+
+	return 0;
+}
+
+static int plic_starting_cpu(unsigned int cpu)
+{
+	struct plic_handler *handler = this_cpu_ptr(&plic_handlers);
+
+	if (plic_parent_irq)
+		enable_percpu_irq(plic_parent_irq,
+				  irq_get_trigger_type(plic_parent_irq));
+	else
+		pr_warn("cpu%d: parent irq not available\n", cpu);
+	plic_set_threshold(handler, PLIC_ENABLE_THRESHOLD);
+
+	return 0;
+}
+
+static int __init plic_init(struct device_node *node,
+		struct device_node *parent)
+{
+	int error = 0, nr_contexts, nr_handlers = 0, i;
+	u32 nr_irqs;
+	struct plic_priv *priv;
+	struct plic_handler *handler;
+	long did = -1;
+	struct sbiret sbi_ret;
+
+	sbi_ret = sbi_ecall(0x534D4541, 0x200, 0, 0, 0, 0, 0, 0);
+	if (!sbi_ret.error)
+		did = sbi_ret.value;
+	else {
+		pr_err("query domain_id from SBI failed, assume domain_id = 0\n");
+		did = 0;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regs = of_iomap(node, 0);
+	if (WARN_ON(!priv->regs)) {
+		error = -EIO;
+		goto out_free_priv;
+	}
+
+	error = -EINVAL;
+	of_property_read_u32(node, "riscv,ndev", &nr_irqs);
+	if (WARN_ON(!nr_irqs))
+		goto out_iounmap;
+
+	nr_contexts = of_irq_count(node);
+	if (WARN_ON(!nr_contexts))
+		goto out_iounmap;
+
+	error = -ENOMEM;
+	priv->irqdomain = irq_domain_add_linear(node, nr_irqs + 1,
+			&plic_irqdomain_ops, priv);
+	if (WARN_ON(!priv->irqdomain))
+		goto out_iounmap;
+
+	for (i = 0; i < nr_contexts; i++) {
+		struct of_phandle_args parent;
+		irq_hw_number_t hwirq;
+		int cpu;
+		long unsigned int hartid;
+
+		if (of_irq_parse_one(node, i, &parent)) {
+			pr_err("failed to parse parent for context %d.\n", i);
+			continue;
+		}
+
+		/*
+		 * Skip contexts other than external interrupts for our
+		 * privilege level.
+		 */
+		if (parent.args[0] != RV_IRQ_EXT) {
+			/* Disable S-mode enable bits if running in M-mode. */
+			if (IS_ENABLED(CONFIG_RISCV_M_MODE)) {
+				void __iomem *enable_base = priv->regs +
+					CONTEXT_ENABLE_BASE +
+					ESS_CONTEXT_MAP(i) * CONTEXT_ENABLE_SIZE;
+
+				for (hwirq = 1; hwirq <= nr_irqs; hwirq++)
+					__plic_toggle(enable_base, hwirq, 0);
+			}
+			continue;
+		}
+
+		error = riscv_of_parent_hartid(parent.np, &hartid);
+		if (hartid < 0) {
+			pr_warn("failed to parse hart ID for context %d.\n", i);
+			continue;
+		}
+
+		cpu = riscv_hartid_to_cpuid(hartid);
+		if (cpu < 0) {
+			pr_warn("Invalid cpuid for context %d\n", i);
+			continue;
+		}
+
+		/* Find parent domain and register chained handler */
+		if (!plic_parent_irq && irq_find_host(parent.np)) {
+			plic_parent_irq = irq_of_parse_and_map(node, i);
+			if (plic_parent_irq)
+				irq_set_chained_handler(plic_parent_irq,
+							plic_handle_irq);
+		}
+
+		/*
+		 * When running in M-mode we need to ignore the S-mode handler.
+		 * Here we assume it always comes later, but that might be a
+		 * little fragile.
+		 */
+		handler = per_cpu_ptr(&plic_handlers, cpu);
+		if (handler->present) {
+			pr_warn("handler already present for context %d.\n", i);
+			plic_set_threshold(handler, PLIC_DISABLE_THRESHOLD);
+			goto done;
+		}
+
+		cpumask_set_cpu(cpu, &priv->lmask);
+		handler->present = true;
+		handler->hart_base = priv->regs + CONTEXT_BASE +
+			ESS_CONTEXT_MAP(i) * CONTEXT_SIZE;
+		raw_spin_lock_init(&handler->enable_lock);
+		handler->enable_base = priv->regs + CONTEXT_ENABLE_BASE +
+			ESS_CONTEXT_MAP(i) * CONTEXT_ENABLE_SIZE;
+		handler->priv = priv;
+done:
+		for (hwirq = 1; hwirq <= nr_irqs; hwirq++)
+			plic_toggle(handler, hwirq, 0);
+		nr_handlers++;
+	}
+
+	/*
+	 * We can have multiple PLIC instances so setup cpuhp state only
+	 * when context handler for current/boot CPU is present.
+	 */
+	handler = this_cpu_ptr(&plic_handlers);
+	if (handler->present && !plic_cpuhp_setup_done) {
+		cpuhp_setup_state(CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING,
+				  "irqchip/sifive/plic:starting",
+				  plic_starting_cpu, plic_dying_cpu);
+		plic_cpuhp_setup_done = true;
+	}
+
+	pr_info("%pOFP: mapped %d interrupts with %d handlers for"
+		" %d contexts, domain_id: %ld.\n", node, nr_irqs, nr_handlers,
+        nr_contexts, did);
+
+	return 0;
+
+out_iounmap:
+	iounmap(priv->regs);
+out_free_priv:
+	kfree(priv);
+	return error;
+}
+
+IRQCHIP_DECLARE(eswin_plic, "eswin,plic0", plic_init);
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 7db51781289e..1b25846d7887 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -532,8 +532,8 @@ static int dw8250_probe(struct platform_device *pdev)
 	p->irq		= irq;
 	p->handle_irq	= dw8250_handle_irq;
 	p->pm		= dw8250_do_pm;
-	p->type		= PORT_8250;
-	p->flags	= UPF_SHARE_IRQ | UPF_FIXED_PORT;
+	p->type		= PORT_16550A;
+	p->flags	= UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE;
 	p->dev		= dev;
 	p->iotype	= UPIO_MEM;
 	p->serial_in	= dw8250_serial_in;
-- 
2.17.1

